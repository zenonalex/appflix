// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CustomException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomExceptionCopyWith<$Res> {
  factory $CustomExceptionCopyWith(
          CustomException value, $Res Function(CustomException) then) =
      _$CustomExceptionCopyWithImpl<$Res, CustomException>;
}

/// @nodoc
class _$CustomExceptionCopyWithImpl<$Res, $Val extends CustomException>
    implements $CustomExceptionCopyWith<$Res> {
  _$CustomExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NetworkExceptionImplCopyWith<$Res> {
  factory _$$NetworkExceptionImplCopyWith(_$NetworkExceptionImpl value,
          $Res Function(_$NetworkExceptionImpl) then) =
      __$$NetworkExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NetworkExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$NetworkExceptionImpl>
    implements _$$NetworkExceptionImplCopyWith<$Res> {
  __$$NetworkExceptionImplCopyWithImpl(_$NetworkExceptionImpl _value,
      $Res Function(_$NetworkExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NetworkExceptionImpl implements NetworkException {
  const _$NetworkExceptionImpl();

  @override
  String toString() {
    return 'CustomException.networkException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NetworkExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return networkException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return networkException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (networkException != null) {
      return networkException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return networkException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return networkException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (networkException != null) {
      return networkException(this);
    }
    return orElse();
  }
}

abstract class NetworkException implements CustomException {
  const factory NetworkException() = _$NetworkExceptionImpl;
}

/// @nodoc
abstract class _$$ServerExceptionImplCopyWith<$Res> {
  factory _$$ServerExceptionImplCopyWith(_$ServerExceptionImpl value,
          $Res Function(_$ServerExceptionImpl) then) =
      __$$ServerExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$ServerExceptionImpl>
    implements _$$ServerExceptionImplCopyWith<$Res> {
  __$$ServerExceptionImplCopyWithImpl(
      _$ServerExceptionImpl _value, $Res Function(_$ServerExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServerExceptionImpl implements ServerException {
  const _$ServerExceptionImpl();

  @override
  String toString() {
    return 'CustomException.serverException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return serverException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return serverException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (serverException != null) {
      return serverException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return serverException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return serverException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (serverException != null) {
      return serverException(this);
    }
    return orElse();
  }
}

abstract class ServerException implements CustomException {
  const factory ServerException() = _$ServerExceptionImpl;
}

/// @nodoc
abstract class _$$LoadFileExceptionImplCopyWith<$Res> {
  factory _$$LoadFileExceptionImplCopyWith(_$LoadFileExceptionImpl value,
          $Res Function(_$LoadFileExceptionImpl) then) =
      __$$LoadFileExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadFileExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$LoadFileExceptionImpl>
    implements _$$LoadFileExceptionImplCopyWith<$Res> {
  __$$LoadFileExceptionImplCopyWithImpl(_$LoadFileExceptionImpl _value,
      $Res Function(_$LoadFileExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadFileExceptionImpl implements LoadFileException {
  const _$LoadFileExceptionImpl();

  @override
  String toString() {
    return 'CustomException.loadFileException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadFileExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return loadFileException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return loadFileException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (loadFileException != null) {
      return loadFileException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return loadFileException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return loadFileException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (loadFileException != null) {
      return loadFileException(this);
    }
    return orElse();
  }
}

abstract class LoadFileException implements CustomException {
  const factory LoadFileException() = _$LoadFileExceptionImpl;
}

/// @nodoc
abstract class _$$StorageExceptionImplCopyWith<$Res> {
  factory _$$StorageExceptionImplCopyWith(_$StorageExceptionImpl value,
          $Res Function(_$StorageExceptionImpl) then) =
      __$$StorageExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StorageExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$StorageExceptionImpl>
    implements _$$StorageExceptionImplCopyWith<$Res> {
  __$$StorageExceptionImplCopyWithImpl(_$StorageExceptionImpl _value,
      $Res Function(_$StorageExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StorageExceptionImpl implements StorageException {
  const _$StorageExceptionImpl();

  @override
  String toString() {
    return 'CustomException.storageException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StorageExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return storageException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return storageException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (storageException != null) {
      return storageException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return storageException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return storageException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (storageException != null) {
      return storageException(this);
    }
    return orElse();
  }
}

abstract class StorageException implements CustomException {
  const factory StorageException() = _$StorageExceptionImpl;
}

/// @nodoc
abstract class _$$UnauthorizedExceptionImplCopyWith<$Res> {
  factory _$$UnauthorizedExceptionImplCopyWith(
          _$UnauthorizedExceptionImpl value,
          $Res Function(_$UnauthorizedExceptionImpl) then) =
      __$$UnauthorizedExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnauthorizedExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$UnauthorizedExceptionImpl>
    implements _$$UnauthorizedExceptionImplCopyWith<$Res> {
  __$$UnauthorizedExceptionImplCopyWithImpl(_$UnauthorizedExceptionImpl _value,
      $Res Function(_$UnauthorizedExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UnauthorizedExceptionImpl implements UnauthorizedException {
  const _$UnauthorizedExceptionImpl();

  @override
  String toString() {
    return 'CustomException.unauthorizedException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnauthorizedExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return unauthorizedException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return unauthorizedException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (unauthorizedException != null) {
      return unauthorizedException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return unauthorizedException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return unauthorizedException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (unauthorizedException != null) {
      return unauthorizedException(this);
    }
    return orElse();
  }
}

abstract class UnauthorizedException implements CustomException {
  const factory UnauthorizedException() = _$UnauthorizedExceptionImpl;
}

/// @nodoc
abstract class _$$BadRequestExceptionImplCopyWith<$Res> {
  factory _$$BadRequestExceptionImplCopyWith(_$BadRequestExceptionImpl value,
          $Res Function(_$BadRequestExceptionImpl) then) =
      __$$BadRequestExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BadRequestExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$BadRequestExceptionImpl>
    implements _$$BadRequestExceptionImplCopyWith<$Res> {
  __$$BadRequestExceptionImplCopyWithImpl(_$BadRequestExceptionImpl _value,
      $Res Function(_$BadRequestExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BadRequestExceptionImpl implements BadRequestException {
  const _$BadRequestExceptionImpl();

  @override
  String toString() {
    return 'CustomException.badRequestException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BadRequestExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return badRequestException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return badRequestException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (badRequestException != null) {
      return badRequestException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return badRequestException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return badRequestException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (badRequestException != null) {
      return badRequestException(this);
    }
    return orElse();
  }
}

abstract class BadRequestException implements CustomException {
  const factory BadRequestException() = _$BadRequestExceptionImpl;
}

/// @nodoc
abstract class _$$TypeConvertionExceptionImplCopyWith<$Res> {
  factory _$$TypeConvertionExceptionImplCopyWith(
          _$TypeConvertionExceptionImpl value,
          $Res Function(_$TypeConvertionExceptionImpl) then) =
      __$$TypeConvertionExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TypeConvertionExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$TypeConvertionExceptionImpl>
    implements _$$TypeConvertionExceptionImplCopyWith<$Res> {
  __$$TypeConvertionExceptionImplCopyWithImpl(
      _$TypeConvertionExceptionImpl _value,
      $Res Function(_$TypeConvertionExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TypeConvertionExceptionImpl implements TypeConvertionException {
  const _$TypeConvertionExceptionImpl();

  @override
  String toString() {
    return 'CustomException.typeConvertionException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TypeConvertionExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return typeConvertionException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return typeConvertionException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (typeConvertionException != null) {
      return typeConvertionException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return typeConvertionException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return typeConvertionException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (typeConvertionException != null) {
      return typeConvertionException(this);
    }
    return orElse();
  }
}

abstract class TypeConvertionException implements CustomException {
  const factory TypeConvertionException() = _$TypeConvertionExceptionImpl;
}

/// @nodoc
abstract class _$$NotFoundExceptionImplCopyWith<$Res> {
  factory _$$NotFoundExceptionImplCopyWith(_$NotFoundExceptionImpl value,
          $Res Function(_$NotFoundExceptionImpl) then) =
      __$$NotFoundExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotFoundExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$NotFoundExceptionImpl>
    implements _$$NotFoundExceptionImplCopyWith<$Res> {
  __$$NotFoundExceptionImplCopyWithImpl(_$NotFoundExceptionImpl _value,
      $Res Function(_$NotFoundExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotFoundExceptionImpl implements NotFoundException {
  const _$NotFoundExceptionImpl();

  @override
  String toString() {
    return 'CustomException.notFoundException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotFoundExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return notFoundException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return notFoundException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (notFoundException != null) {
      return notFoundException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return notFoundException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return notFoundException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (notFoundException != null) {
      return notFoundException(this);
    }
    return orElse();
  }
}

abstract class NotFoundException implements CustomException {
  const factory NotFoundException() = _$NotFoundExceptionImpl;
}

/// @nodoc
abstract class _$$ConflictExceptionImplCopyWith<$Res> {
  factory _$$ConflictExceptionImplCopyWith(_$ConflictExceptionImpl value,
          $Res Function(_$ConflictExceptionImpl) then) =
      __$$ConflictExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConflictExceptionImplCopyWithImpl<$Res>
    extends _$CustomExceptionCopyWithImpl<$Res, _$ConflictExceptionImpl>
    implements _$$ConflictExceptionImplCopyWith<$Res> {
  __$$ConflictExceptionImplCopyWithImpl(_$ConflictExceptionImpl _value,
      $Res Function(_$ConflictExceptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConflictExceptionImpl implements ConflictException {
  const _$ConflictExceptionImpl();

  @override
  String toString() {
    return 'CustomException.conflictException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConflictExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkException,
    required TResult Function() serverException,
    required TResult Function() loadFileException,
    required TResult Function() storageException,
    required TResult Function() unauthorizedException,
    required TResult Function() badRequestException,
    required TResult Function() typeConvertionException,
    required TResult Function() notFoundException,
    required TResult Function() conflictException,
  }) {
    return conflictException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? networkException,
    TResult? Function()? serverException,
    TResult? Function()? loadFileException,
    TResult? Function()? storageException,
    TResult? Function()? unauthorizedException,
    TResult? Function()? badRequestException,
    TResult? Function()? typeConvertionException,
    TResult? Function()? notFoundException,
    TResult? Function()? conflictException,
  }) {
    return conflictException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkException,
    TResult Function()? serverException,
    TResult Function()? loadFileException,
    TResult Function()? storageException,
    TResult Function()? unauthorizedException,
    TResult Function()? badRequestException,
    TResult Function()? typeConvertionException,
    TResult Function()? notFoundException,
    TResult Function()? conflictException,
    required TResult orElse(),
  }) {
    if (conflictException != null) {
      return conflictException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NetworkException value) networkException,
    required TResult Function(ServerException value) serverException,
    required TResult Function(LoadFileException value) loadFileException,
    required TResult Function(StorageException value) storageException,
    required TResult Function(UnauthorizedException value)
        unauthorizedException,
    required TResult Function(BadRequestException value) badRequestException,
    required TResult Function(TypeConvertionException value)
        typeConvertionException,
    required TResult Function(NotFoundException value) notFoundException,
    required TResult Function(ConflictException value) conflictException,
  }) {
    return conflictException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NetworkException value)? networkException,
    TResult? Function(ServerException value)? serverException,
    TResult? Function(LoadFileException value)? loadFileException,
    TResult? Function(StorageException value)? storageException,
    TResult? Function(UnauthorizedException value)? unauthorizedException,
    TResult? Function(BadRequestException value)? badRequestException,
    TResult? Function(TypeConvertionException value)? typeConvertionException,
    TResult? Function(NotFoundException value)? notFoundException,
    TResult? Function(ConflictException value)? conflictException,
  }) {
    return conflictException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NetworkException value)? networkException,
    TResult Function(ServerException value)? serverException,
    TResult Function(LoadFileException value)? loadFileException,
    TResult Function(StorageException value)? storageException,
    TResult Function(UnauthorizedException value)? unauthorizedException,
    TResult Function(BadRequestException value)? badRequestException,
    TResult Function(TypeConvertionException value)? typeConvertionException,
    TResult Function(NotFoundException value)? notFoundException,
    TResult Function(ConflictException value)? conflictException,
    required TResult orElse(),
  }) {
    if (conflictException != null) {
      return conflictException(this);
    }
    return orElse();
  }
}

abstract class ConflictException implements CustomException {
  const factory ConflictException() = _$ConflictExceptionImpl;
}
